// â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•—
// â•‘            SCHEDULE.PRISMA - APPOINTMENT SCHEDULING SYSTEM                   â•‘
// â•‘                    Complete Beginner's Guide                                 â•‘
// â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// ğŸ“š WHAT IS THIS FILE?
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// This file defines the SCHEDULING DOMAIN - how doctors manage their availability:
// - Schedule       â†’ Time slot definitions (30-minute intervals)
// - DoctorSchedule â†’ Junction table linking doctors to their available slots
//
// ğŸ¯ BUSINESS CONTEXT
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Imagine a doctor's calendar:
//
//     Monday, Jan 15, 2026
//     â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
//     â”‚  9:00 AM   â”‚ âœ… Available (Dr. Smith)      â”‚
//     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
//     â”‚  9:30 AM   â”‚ âŒ Booked (Patient: John)     â”‚
//     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
//     â”‚ 10:00 AM   â”‚ âœ… Available (Dr. Smith)      â”‚
//     â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
//     â”‚ 10:30 AM   â”‚ â¬œ Not Available              â”‚
//     â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// Each row is a "Schedule" record (time slot).
// Whether Dr. Smith is available is tracked in "DoctorSchedule".
//
// ğŸ“ DESIGN PATTERN: MANY-TO-MANY WITH JUNCTION TABLE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Why not just put doctorId directly on Schedule?
//
// WRONG APPROACH (if doctorId on Schedule):
// - One schedule = one doctor only
// - What if Dr. Smith AND Dr. Jones both work 9-10am Monday?
// - Would need duplicate Schedule records
//
// RIGHT APPROACH (junction table):
// - One Schedule = one time slot (reusable)
// - Many doctors can link to same schedule
// - Each link tracks if THAT doctor is booked
//
// DATABASE TABLES:
//
// schedules              doctor_schedules          doctors
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”    â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ id             â”‚    â”‚ doctorId (FK)   â”€â”€â”€â”€â”€â”€â”€â”€â”‚ id           â”‚
// â”‚ startDate      â”‚    â”‚ scheduleId (FK) â”€â”€â”€â”€â”€â”€â”€â”€â”‚ name         â”‚
// â”‚ endDate        â”‚    â”‚ isBooked             â”‚  â”‚ ...          â”‚
// â”‚ startTime      â”‚    â”‚ createdAt            â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
// â”‚ endTime        â”‚    â”‚ updatedAt            â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜    â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//         â”‚                     â–²
//         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// ğŸ“ PostgreSQL TIME TYPE
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// PostgreSQL has a special TIME type for storing time-of-day only.
//
// WRONG: Storing time as string
// startTime: "09:00:00"  // Can't do time math!
//
// WRONG: Storing time as full datetime
// startTime: "2026-01-15T09:00:00Z"  // Date part is wasted space
//
// RIGHT: PostgreSQL TIME type
// startTime: TIME '09:00:00'  // Only time, efficient storage
//
// BENEFITS OF TIME TYPE:
// âœ… Native time comparisons: WHERE startTime < '12:00:00'
// âœ… Time arithmetic: startTime + INTERVAL '30 minutes'
// âœ… Proper timezone handling with TIMETZ variant
// âœ… Only 8 bytes vs 8+ bytes for timestamp
// âœ… Query optimizer understands it
//
// JAVASCRIPT HANDLING:
// In JavaScript, TIME values come back as Date objects.
// The date portion is set to 1970-01-01 (Unix epoch).
//
// const schedule = await prisma.schedule.findFirst();
// console.log(schedule.startTime);
// // Output: 1970-01-01T09:00:00.000Z
// // Only the time portion (09:00:00) matters!
//
// WORKING WITH TIME IN CODE:
// import { format } from 'date-fns';
// const timeString = format(schedule.startTime, 'HH:mm');  // "09:00"
//
// ğŸ“ UNIQUE CONSTRAINT PATTERN
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// We use a COMPOSITE UNIQUE constraint to prevent duplicate slots:
//
// @@unique([startDate, startTime, endTime])
//
// This means: "No two schedules can have the same date + start + end time"
//
// ALLOWED:
// Schedule 1: Jan 15, 9:00-9:30 âœ…
// Schedule 2: Jan 15, 9:30-10:00 âœ…  (different time)
// Schedule 3: Jan 16, 9:00-9:30 âœ…  (different date)
//
// NOT ALLOWED:
// Schedule 1: Jan 15, 9:00-9:30 âœ…
// Schedule 2: Jan 15, 9:00-9:30 âŒ  (duplicate!)
//
// ğŸ“– DOCUMENTATION:
// - Many-to-Many: https://www.prisma.io/docs/orm/prisma-schema/data-model/relations/many-to-many-relations
// - PostgreSQL TIME: https://www.postgresql.org/docs/current/datatype-datetime.html
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚                            SCHEDULE MODEL                                    â”‚
// â”‚              Time slot definition for appointments                           â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// PURPOSE:
// Represents a bookable time slot (typically 30 minutes).
// Schedules are SHARED - multiple doctors can be available at the same time.
//
// LIFECYCLE:
// 1. Admin creates schedule slots (9:00, 9:30, 10:00, etc.)
// 2. Doctors link themselves via DoctorSchedule
// 3. Patients book appointments (creates Appointment, marks DoctorSchedule.isBooked)
// 4. After appointment, slot becomes available again
//
/// Schedule - Time slot definition for appointments
/// Represents a 30-minute interval that can be booked
///
/// @example Creating a schedule for 9:00 AM - 9:30 AM on Jan 15, 2026:
///   {
///     startDate: new Date('2026-01-15'),
///     endDate: new Date('2026-01-15'),
///     startTime: new Date('1970-01-01T09:00:00Z'),  // Only time portion matters
///     endTime: new Date('1970-01-01T09:30:00Z')     // Only time portion matters
///   }
///
/// @note PostgreSQL TIME type stores time-of-day without date component.
///       In JavaScript, you'll work with Date objects but only the time portion
///       is stored in the database. Use date-fns or dayjs for time manipulation.
model Schedule {
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // PRIMARY KEY: UUID v7 (time-ordered)
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    id String @id @default(uuid(7))

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // DATE RANGE: When this schedule is valid
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // @db.Date â†’ PostgreSQL DATE type (YYYY-MM-DD only, no time)
    //
    // WHY SEPARATE startDate/endDate?
    // - Single day: startDate = endDate = Jan 15
    // - Multiple days: startDate = Jan 15, endDate = Jan 20 (repeating slot)
    //
    // SINGLE DAY EXAMPLE:
    // { startDate: '2026-01-15', endDate: '2026-01-15' }
    // = This slot exists ONLY on January 15th
    //
    // DATE RANGE EXAMPLE (for recurring schedules):
    // { startDate: '2026-01-15', endDate: '2026-01-31' }
    // = This slot repeats every day from Jan 15-31
    //
    // NOTE: In JavaScript, dates are received as:
    // schedule.startDate = new Date('2026-01-15T00:00:00.000Z')
    //
    startDate DateTime @db.Date
    endDate   DateTime @db.Date

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // TIME SLOTS: PostgreSQL native TIME type
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // @db.Time â†’ PostgreSQL TIME type (HH:MM:SS only, no date)
    //
    // WHY TIME TYPE (not String or Timestamp)?
    // âœ… Native time comparisons: WHERE startTime < '12:00:00'
    // âœ… Time arithmetic: startTime + INTERVAL '30 minutes'
    // âœ… Better query optimization (index-friendly)
    // âœ… Smaller storage (8 bytes)
    //
    // STORAGE FORMAT:
    // PostgreSQL stores: TIME '09:30:00'
    // JavaScript receives: Date('1970-01-01T09:30:00.000Z')
    // Only the time portion matters!
    //
    // WORKING WITH TIME IN CODE:
    // // Creating a time value for 9:30 AM:
    // const startTime = new Date('1970-01-01T09:30:00.000Z');
    //
    // // Extracting time from result:
    // const hours = schedule.startTime.getUTCHours();   // 9
    // const minutes = schedule.startTime.getUTCMinutes(); // 30
    //
    // // Using date-fns for formatting:
    // import { format } from 'date-fns';
    // const timeStr = format(schedule.startTime, 'HH:mm'); // "09:30"
    //
    // TYPICAL 30-MINUTE SLOTS:
    // startTime: 09:00, endTime: 09:30
    // startTime: 09:30, endTime: 10:00
    // startTime: 10:00, endTime: 10:30
    //
    startTime DateTime @db.Time
    endTime   DateTime @db.Time

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // AUDIT FIELDS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    createdAt DateTime  @default(now())
    updatedAt DateTime  @updatedAt
    isDeleted Boolean   @default(false)
    deletedAt DateTime?

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // RELATIONS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // doctorSchedules: Doctors available at this time slot
    // One schedule can have MANY doctors (via junction table)
    //
    // appointment: The booking for this slot (optional)
    // Only ONE appointment per schedule (1:1)
    // Optional because slot might not be booked yet
    //
    doctorSchedules DoctorSchedule[]
    appointment     Appointment?

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // UNIQUE CONSTRAINT: Prevent duplicate time slots
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // @@unique([startDate, startTime, endTime])
    //
    // WHAT IT PREVENTS:
    // Two schedules with same date AND same time range
    //
    // ALLOWED:
    // { startDate: Jan 15, startTime: 9:00, endTime: 9:30 } âœ…
    // { startDate: Jan 15, startTime: 9:30, endTime: 10:00 } âœ… Different time
    // { startDate: Jan 16, startTime: 9:00, endTime: 9:30 } âœ… Different date
    //
    // REJECTED:
    // { startDate: Jan 15, startTime: 9:00, endTime: 9:30 } Already exists!
    //
    @@unique([startDate, startTime, endTime], name: "unique_schedule_slot")
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // INDEXES: Query performance optimization
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // schedule_date_range_idx:
    // - Composite index on startDate + endDate
    // - Speeds up: "Find schedules between Jan 15 and Jan 31"
    // - Query: WHERE startDate >= '2026-01-15' AND endDate <= '2026-01-31'
    //
    // schedule_time_range_idx:
    // - Composite index on startTime + endTime
    // - Speeds up: "Find morning slots" (9am-12pm)
    // - Query: WHERE startTime >= '09:00' AND endTime <= '12:00'
    //
    // schedule_deleted_idx:
    // - Essential for soft delete filtering
    // - Every query should filter: WHERE isDeleted = false
    //
    @@index([startDate, endDate], map: "schedule_date_range_idx")
    @@index([startTime, endTime], map: "schedule_time_range_idx")
    @@index([isDeleted], map: "schedule_deleted_idx")
    // Table mapping: Prisma "Schedule" â†’ PostgreSQL "schedules"
    @@map("schedules")
}

// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚                         DOCTORSCHEDULE MODEL                                 â”‚
// â”‚              Junction table for Doctor-Schedule relationship                 â”‚
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// PURPOSE:
// Links doctors to their available time slots.
// Tracks whether each doctor-schedule combination is booked.
//
// WHY A JUNCTION TABLE?
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Without junction table (WRONG):
// Doctor 1 available 9-10am â†’ Can't share with Doctor 2
//
// With junction table (RIGHT):
// Schedule: 9-10am slot (shared definition)
// DoctorSchedule: Dr. Smith â†’ 9-10am (not booked)
// DoctorSchedule: Dr. Jones â†’ 9-10am (booked)
//
// DATABASE REPRESENTATION:
//
// doctor_schedules
// â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
// â”‚ doctorId     â”‚ scheduleId    â”‚ isBooked â”‚
// â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
// â”‚ dr_smith_123 â”‚ slot_9am_456  â”‚ false    â”‚  â† Dr. Smith available
// â”‚ dr_jones_789 â”‚ slot_9am_456  â”‚ true     â”‚  â† Dr. Jones booked
// â”‚ dr_smith_123 â”‚ slot_10am_012 â”‚ true     â”‚  â† Dr. Smith booked
// â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
//
// COMPOSITE PRIMARY KEY:
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// Primary key is (doctorId + scheduleId) together.
// This automatically prevents duplicate entries.
//
// BOOKING FLOW:
// â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
// 1. Patient selects doctor + time slot
// 2. Check: SELECT * FROM doctor_schedules WHERE ... AND isBooked = false
// 3. If available: UPDATE doctor_schedules SET isBooked = true
// 4. Create Appointment record
// 5. Process payment
//
/// DoctorSchedule - Junction table for Doctor-Schedule relationship
/// Tracks which doctors are available at which time slots
model DoctorSchedule {
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // COMPOSITE PRIMARY KEY FIELDS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // These two fields TOGETHER form the primary key.
    // See @@id([doctorId, scheduleId]) at the bottom.
    //
    // WHAT THIS MEANS:
    // - No separate 'id' column needed
    // - Combination must be unique
    // - Can't have two records with same doctor + schedule
    //
    doctorId   String
    scheduleId String

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // BOOKING STATUS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // @default(false) â†’ New doctor-schedule links start as available
    //
    // STATES:
    // false = Doctor is available at this time
    // true  = Doctor has a booking at this time
    //
    // UPDATED WHEN:
    // - Appointment created â†’ isBooked = true
    // - Appointment cancelled â†’ isBooked = false
    //
    isBooked Boolean @default(false)

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // AUDIT FIELDS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // WHY AUDIT FIELDS ON JUNCTION TABLE?
    // - Track when doctor added this availability
    // - Debug booking issues
    // - Analytics: When do doctors add availability?
    //
    createdAt DateTime @default(now())
    updatedAt DateTime @updatedAt

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // RELATIONS WITH REFERENTIAL ACTIONS
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // @relation(fields: [doctorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    //
    // BREAKDOWN:
    // - fields: [doctorId]    â†’ This table's foreign key column
    // - references: [id]      â†’ Doctor table's primary key
    // - onDelete: Cascade     â†’ If doctor deleted, delete all their schedules
    // - onUpdate: Cascade     â†’ If doctor.id changes, update here too
    //
    // CASCADE BEHAVIOR:
    // DELETE FROM doctors WHERE id = 'dr_smith';
    // â†’ Automatically: DELETE FROM doctor_schedules WHERE doctorId = 'dr_smith';
    //
    // This prevents orphan records (schedules pointing to non-existent doctors).
    //
    doctor   Doctor   @relation(fields: [doctorId], references: [id], onDelete: Cascade, onUpdate: Cascade)
    schedule Schedule @relation(fields: [scheduleId], references: [id], onDelete: Cascade, onUpdate: Cascade)

    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // COMPOSITE PRIMARY KEY
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // @@id([doctorId, scheduleId])
    //
    // WHY COMPOSITE KEY?
    // - No need for separate UUID column
    // - Automatically enforces uniqueness
    // - More efficient queries (natural key)
    //
    // IN SQL:
    // CREATE TABLE doctor_schedules (
    //   doctor_id UUID,
    //   schedule_id UUID,
    //   is_booked BOOLEAN,
    //   PRIMARY KEY (doctor_id, schedule_id)  â† Composite!
    // );
    //
    @@id([doctorId, scheduleId])
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    // INDEXES FOR COMMON QUERIES
    // â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
    //
    // doctor_schedule_booking_idx:
    // - Composite index: doctorId + isBooked
    // - Use case: "Find Dr. Smith's available slots"
    // - Query: WHERE doctorId = 'x' AND isBooked = false
    //
    // doctor_schedule_schedule_idx:
    // - Index on scheduleId alone
    // - Use case: "Find all doctors available at 9am slot"
    // - Query: WHERE scheduleId = 'slot_9am'
    //
    // doctor_schedule_booked_idx:
    // - Index on isBooked alone
    // - Use case: "Count total bookings" or "Find all available slots"
    //
    @@index([doctorId, isBooked], map: "doctor_schedule_booking_idx")
    @@index([scheduleId], map: "doctor_schedule_schedule_idx")
    @@index([isBooked], map: "doctor_schedule_booked_idx")
    // Table mapping
    @@map("doctor_schedules")
}

// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
// QUICK REFERENCE: WORKING WITH SCHEDULES
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
//
// CREATING A SCHEDULE:
// const schedule = await prisma.schedule.create({
//   data: {
//     startDate: new Date('2026-01-15'),
//     endDate: new Date('2026-01-15'),
//     startTime: new Date('1970-01-01T09:00:00Z'),  // 9:00 AM
//     endTime: new Date('1970-01-01T09:30:00Z'),    // 9:30 AM
//   }
// });
//
// DOCTOR ADDING AVAILABILITY:
// await prisma.doctorSchedule.create({
//   data: {
//     doctorId: 'doctor_123',
//     scheduleId: schedule.id,
//     isBooked: false
//   }
// });
//
// FINDING AVAILABLE SLOTS FOR A DOCTOR:
// const available = await prisma.doctorSchedule.findMany({
//   where: {
//     doctorId: 'doctor_123',
//     isBooked: false,
//     schedule: {
//       startDate: { gte: new Date('2026-01-15') },
//       isDeleted: false
//     }
//   },
//   include: { schedule: true }
// });
//
// BOOKING A SLOT:
// await prisma.$transaction([
//   prisma.doctorSchedule.update({
//     where: { doctorId_scheduleId: { doctorId: 'x', scheduleId: 'y' } },
//     data: { isBooked: true }
//   }),
//   prisma.appointment.create({
//     data: {
//       doctorId: 'x',
//       patientId: 'patient_123',
//       scheduleId: 'y',
//       status: 'SCHEDULED'
//     }
//   })
// ]);
// â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
